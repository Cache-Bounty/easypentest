## easypentest : Scripts & Cheatsheet for Linux and Windows binary pentesting.


## Linux :

### 1. Binary Static Analysis: 

<details><summary><b>[CheckSec : Checking security properties of binary]</b></summary>

Link: https://github.com/slimm609/checksec.sh

Check by file path : `./checksec --dir=/folder1/folder2`

Check by directory path : `./checksec --file=/folder1/binary`

</details>

<details><summary><b>RPATH</b></summary>
Checking RPATH : 

 `objdump -p /binary | grep -i rpath`
 
 `readelf -a /binary | grep -i rpath`


Compiling with RPATH :

`gcc -Wl,-rpath=/binary program.c`


Removing RPATH :

`patchelf --remove-rpath /binary`


Changing RPATH :

`patchelf --force-rpath --set-rpath "New-Rpath" /binary`

`chrpath -r 'New-Rpath' /binary `

</details>

<details><summary><b>Stack Canary</b></summary>

Compiling with Stack Canary :
`gcc tmp.c -fstack-protector-all`

Checking if Stack Canary is enforced :
`readelf -s a.out | grep -i stack_chk`

Demo :
```
[root@linux]# gcc tmp.c -fstack-protector-all

[root@linux]# readelf -s a.out | grep -i stack_chk
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (2)
    50: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2
 ```   
Compiling without Stack Canary :
```
[root@linux]# gcc tmp.c

[root@linux]# readelf -s a.out | grep -i stack_chk
```
`Note : No output returned. By default gcc does not enforce stack canaries.`

</details>


<details><summary><b>Symbols (linker symbols)</b></summary>


https://stackoverflow.com/questions/2577068/what-is-symbol-table-and-how-is-it-integrated-into-the-executable

Checking if symbols are present :

`readelf --symbols a.out | grep -i symtab`
`file a.out | grep -i "not stripped"`

Demo :
```
[root@linux]# gcc tmp.c
[root@linux]# readelf --symbols a.out | grep -i symtab
Symbol table '.symtab' contains 65 entries:
[root@linux]# file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=be5bf11b01830b497087943a285d6f4e3f74a24e, not stripped
```

Removing symbols from compiled binary:

`strip a.out`

Demo :
```
[root@linux]# strip a.out
[root@linux]# readelf --symbols a.out | grep -i symtab
[root@linux]# file a.out | grep -i "not stripped"
```

Compiling without symbols :
`gcc -s tmp.c`

Demo :
```
[root@linux]# gcc -s tmp.c
[root@linux]# readelf --symbols a.out | grep -i symtab
[root@linux]# file a.out | grep -i "not stripped"
```
</details>


<details><summary><b>Symbols (debug symbols)</b></summary>

https://stackoverflow.com/questions/2577068/what-is-symbol-table-and-how-is-it-integrated-into-the-executable

`TODO`

</details>

<details><summary><b>PIE</b></summary>

Compiling with PIE :

`gcc -pie -fPIE tmp.c`

Checking if PIE is enabled :

`./checksec --file=a.out`

PIE vs PIC : https://mropert.github.io/2018/02/02/pic_pie_sanitizers/

</details>

<details><summary><b>RELRO</b></summary>

https://medium.com/@HockeyInJune/relro-relocation-read-only-c8d0933faef3


Compiling with Full RELRO : Recommended, but can increase the program loading time.

`gcc -Wl,-z,relro,-z,now tmp.c`

Compiling with Partial RELRO : Ok

`gcc -Wl,-z,relro tmp.c`

Compiling without RELRO : Not Ok

`gcc -Wl,-z,norelro tmp.c`

Checking RELRO : 

`./checksec --file=a.out`

```
https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro

RELRO is a generic mitigation technique to harden the data sections of an ELF binary/process. Using full RELRO has a slight performance impact during application startup (as the linker has to populate the GOT entries before entering the main function). 
```

</details>

<details><summary><b>Fortify</b></summary>

https://access.redhat.com/blogs/766093/posts/1976213
https://stackoverflow.com/questions/13517526/difference-between-gcc-d-fortify-source-1-and-d-fortify-source-2

Compiling with Fortify : 

`gcc -D_FORTIFY_SOURCE=2 -O2 tmp.c`

Checking :

`./checksec --file=a.out`

</details>



### 2. Process Analysis: 

<details><summary><b> Process Tree </b></summary>

List all process tree : 

`pstree -a -lnp`

Demo :

```
[root@linux /]# pstree -a -lnp
systemd,1 --switched-root --system --deserialize 21
  |-systemd-journal,482
  |-lvmetad,504 -f
  |-systemd-udevd,517
  |-auditd,615
  |   |-{auditd},616
  |   `-audispd,617
  |       |-sedispatch,622
  |       `-{audispd},623
  |-dbus-daemon,642 --system --address=systemd: --nofork --nopidfile --systemd-activation
  |-ModemManager,647
  |   |-{ModemManager},671
  |   `-{ModemManager},686
  |-VGAuthService,648 -s
  |-systemd-logind,653
  |-avahi-daemon,654
  |   `-avahi-daemon,673
```
List process tree of only given user :

`pstree -a -lnp root` // Here "root" is provided username.

List process tree of only given PID (parent process id) :

`pstree -a -lnp 0` // Here "0" is provided process id.

</details>

<details><summary><b> Process Files (libraries, IP sockets, folders, etc) </b></summary>

List all files (libraries, IP sockets, folders, etc) opened by given process ID :

`lsof -p  3259`

Demo:
```
[root@linux /]# lsof -p  3259
COMMAND    PID      USER   FD      TYPE             DEVICE SIZE/OFF     NODE NAME
command1 3259 root  cwd       DIR              253,0     4096  2640063 /dir/bin/binary
command1 3259 root  rtd       DIR              253,0     4096        2 /
command1 3259 root  txt       REG              253,0  2865976  2640066 /dir/bin/binary
command1 3259 root  mem       REG              253,0   111080   399214 /usr/lib64/libresolv-2.17.so
command1 3259 root  mem       REG              253,0    27776   394567 /usr/lib64/libnss_dns-2.17.so
command1 3259 root    0r      CHR                1,3      0t0     1031 /dev/null
command1 3259 root    3u     unix 0xffff880035cf5800      0t0  8591925 socket
command1 3259 root    4u     a_inode             0,9        0     5880 [eventpoll]

```


List all processes that are using given file/folder (libraries, IP sockets, folders, etc) :

`lsof /directory`

Demo:
```
[root@linux /]# lsof  /dir/bin/
COMMAND     PID      USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
command1 26859 username1  cwd    DIR  253,0     4096 2640065 /dir/bin
command2 26880 root  cwd    DIR  253,0     4096 2640065 /dir/bin
```

`lsof /directory/binary`

Demo :
```
[root@linux /]# lsof /bin/bash
COMMAND    PID USER  FD   TYPE DEVICE SIZE/OFF   NODE NAME
ksmtuned   731 root txt    REG  253,0   960472 396293 /usr/bin/bash
bash     31491 root txt    REG  253,0   960472 396293 /usr/bin/bash
```


</details>

### 3. Network Analysis: 

<details><summary><b> Lists IP sockets </b></summary>

List Process Id, IP, Port, Command, Username:

`lsof -i -n -P`

Demo :
```
[root@linux /]# lsof -i -n -P
COMMAND     PID      USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
systemd       1      root   36u  IPv4    13982      0t0  TCP *:23 (LISTEN)
chronyd     730    chrony    1u  IPv4    16356      0t0  UDP 127.0.0.1:323
sshd      31483      root    3u  IPv4 10068735      0t0  TCP 10.10.10.10:22->20.20.20.20:51109 (ESTABLISHED)

```
</details>

