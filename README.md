## easypentest : Scripts & Cheatsheet for Linux and Windows binary pentesting.


## Linux :

#### 1. Binary Static Analysis: 

<details><summary><b>[CheckSec : Checking security properties of binary]</b></summary>

Link: https://github.com/slimm609/checksec.sh

Check by file path : `./checksec --dir=/folder1/folder2`

Check by directory path : `./checksec --file=/folder1/binary`

</details>

<details><summary><b>RPATH</b></summary>
Checking RPATH : 

 `objdump -p /binary | grep -i rpath`
 
 `readelf -a /binary | grep -i rpath`


Compiling with RPATH :

`gcc -Wl,-rpath=/binary program.c`


Removing RPATH :

`patchelf --remove-rpath /binary`


Changing RPATH :

`patchelf --force-rpath --set-rpath "New-Rpath" /binary`

`chrpath -r 'New-Rpath' /binary `

</details>

<details><summary><b>Stack Canary</b></summary>

Compiling with Stack Canary :
`gcc tmp.c -fstack-protector-all`

Checking if Stack Canary is enforced :
`readelf -s a.out | grep -i stack_chk`

Demo :
```
[root@linux]# gcc tmp.c -fstack-protector-all

[root@linux]# readelf -s a.out | grep -i stack_chk
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (2)
    50: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2
 ```   
Compiling without Stack Canary :
```
[root@linux]# gcc tmp.c

[root@linux]# readelf -s a.out | grep -i stack_chk
```
`Note : No output returned. By default gcc does not enforce stack canaries.`

</details>


<details><summary><b>Symbols (linker symbols)</b></summary>


https://stackoverflow.com/questions/2577068/what-is-symbol-table-and-how-is-it-integrated-into-the-executable

Checking if symbols are present :

`readelf --symbols a.out | grep -i symtab`
`file a.out | grep -i "not stripped"`

Demo :
```
[root@linux]# gcc tmp.c
[root@linux]# readelf --symbols a.out | grep -i symtab
Symbol table '.symtab' contains 65 entries:
[root@linux]# file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=be5bf11b01830b497087943a285d6f4e3f74a24e, not stripped
```

Removing symbols from compiled binary:

`strip a.out`

Demo :
```
[root@linux]# strip a.out
[root@linux]# readelf --symbols a.out | grep -i symtab
[root@linux]# file a.out | grep -i "not stripped"
```

Compiling without symbols :
`gcc -s tmp.c`

Demo :
```
[root@linux]# gcc -s tmp.c
[root@linux]# readelf --symbols a.out | grep -i symtab
[root@linux]# file a.out | grep -i "not stripped"
```
</details>


<details><summary><b>Symbols (debug symbols)</b></summary>

https://stackoverflow.com/questions/2577068/what-is-symbol-table-and-how-is-it-integrated-into-the-executable

`TODO`

</details>

<details><summary><b>PIE</b></summary>

Compiling with PIE :

`gcc -pie -fPIE tmp.c`

Checking if PIE is enabled :

`./checksec --file=a.out`

PIE vs PIC : https://mropert.github.io/2018/02/02/pic_pie_sanitizers/

</details>

<details><summary><b>RELRO</b></summary>

https://medium.com/@HockeyInJune/relro-relocation-read-only-c8d0933faef3


Compiling with Full RELRO : Recommended, but can increase the program loading time.

`gcc -Wl,-z,relro,-z,now tmp.c`

Compiling with Partial RELRO : Ok

`gcc -Wl,-z,relro tmp.c`

Compiling without RELRO : Not Ok

`gcc -Wl,-z,norelro tmp.c`

Checking RELRO : 

`./checksec --file=a.out`

```
https://www.redhat.com/en/blog/hardening-elf-binaries-using-relocation-read-only-relro

RELRO is a generic mitigation technique to harden the data sections of an ELF binary/process. Using full RELRO has a slight performance impact during application startup (as the linker has to populate the GOT entries before entering the main function). 
```

</details>

<details><summary><b>Fortify</b></summary>

https://access.redhat.com/blogs/766093/posts/1976213
https://stackoverflow.com/questions/13517526/difference-between-gcc-d-fortify-source-1-and-d-fortify-source-2

Compiling with Fortify : 

`gcc -D_FORTIFY_SOURCE=2 -O2 tmp.c`

Checking :

`./checksec --file=a.out`

</details>

#### 2. Process Analysis: 

<details><summary><b> Process Tree </b></summary>

List all process tree : 

`pstree -a -lnp`

List process tree of only given user :

`pstree -a -lnp root` // Here "root" is provided username.

List process tree of only given PID (parent process id) :

`pstree -a -lnp 0` // Here "0" is provided process id.

</details>





